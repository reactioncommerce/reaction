"The product price or price range for a specific currency"
type ProductPricingInfo {
  """
  A comparison price value, usually MSRP. If `price` is null, this will also be null. That is,
  only purchasable variants will have a `compareAtPrice`.
  """
  compareAtPrice: Money

  "The code for the currency these pricing details applies to"
  currency: Currency!

  "Pricing converted to specified currency"
  currencyExchangePricing(
    "Code for the currency in which you want to see pricing info"
    currencyCode: String!
  ): CurrencyExchangeProductPricingInfo

  """
  UI should display this price. If a product has multiple potential prices depending on selected
  variants and options, then this is a price range string such as "$3.95 - $6.99". It includes the currency
  symbols.
  """
  displayPrice: String!

  "The price of the most expensive possible variant+option combination"
  maxPrice: Float!

  "The price of the least expensive possible variant+option combination"
  minPrice: Float!

  """
  For variants with no options and for options, this will always be set to a price. For variants
  with options and products, this will be `null`. There must be a price for a variant to be
  added to a cart or purchased. Otherwise you would instead add one of its child options to a cart.
  """
  price: Float
}

"The product price or price range for a specific currency"
type CurrencyExchangeProductPricingInfo {
  """
  A comparison price value, usually MSRP. If `price` is null, this will also be null. That is,
  only purchasable variants will have a `compareAtPrice`.
  """
  compareAtPrice: Money

  "The code for the currency these pricing details applies to"
  currency: Currency!

  """
  UI should display this price. If a product has multiple potential prices depending on selected
  variants and options, then this is a price range string such as "$3.95 - $6.99". It includes the currency
  symbols.
  """
  displayPrice: String!

  "The price of the most expensive possible variant+option combination"
  maxPrice: Float!

  "The price of the least expensive possible variant+option combination"
  minPrice: Float!

  """
  For variants with no options and for options, this will always be set to a price. For variants
  with options and products, this will be `null`. There must be a price for a variant to be
  added to a cart or purchased. Otherwise you would instead add one of its child options to a cart.
  """
  price: Float
}

"Product price range"
type ProductPriceRange {
  "Maximum price in range"
  max: Float

  "Minimum price in range"
  min: Float

  "Price range display"
  range: String
}

extend type CatalogProduct {
  "Price and related information, per currency"
  pricing: [ProductPricingInfo]!
}

extend type CatalogProductVariant {
  "Price and related information, per currency"
  pricing: [ProductPricingInfo]!
}

extend type Product {
  "Price range"
  price: ProductPriceRange @deprecated(reason: "Use `pricing`")

  "Pricing information"
  pricing: ProductPricingInfo!
}

extend type ProductVariant {
  "Compare at price of the variant"
  compareAtPrice: Float @deprecated(reason: "Use `pricing`")

  "Price of the variant"
  price: Float @deprecated(reason: "Use `pricing`")

  "Pricing information"
  pricing: ProductPricingInfo!
}

extend input ProductVariantInput {
  "Variant compareAtPrice. DEPRECATED. Use the `updateProductVariantPrices` mutation to set product variant prices."
  # @deprecated isn't allowed on input fields yet. See See https://github.com/graphql/graphql-spec/pull/525
  compareAtPrice: Float

  "Variant price. DEPRECATED. Use the `updateProductVariantPrices` mutation to set product variant prices."
  # @deprecated isn't allowed on input fields yet. See See https://github.com/graphql/graphql-spec/pull/525
  price: Float
}

"Input for the `updateProductVariantField` mutation"
input UpdateProductVariantPricesInput  {
  "Prices to update"
  prices: ProductVariantPricesInput!

  "ID of shop that owns the variant to update"
  shopId: ID!

  "ID of variant to update"
  variantId: ID!
}

"Mutation input for a product variant or option"
input ProductVariantPricesInput {
  "Variant compareAtPrice"
  compareAtPrice: Float

  "Variant price"
  price: Float
}

extend type Mutation {
  "Update an existing product variants prices"
  updateProductVariantPrices(
    "Mutation input"
    input: UpdateProductVariantPricesInput!
  ): UpdateProductVariantPricesPayload!
}

"Response payload of `updateProductVariantPricesField` mutation"
type UpdateProductVariantPricesPayload  {
  "The same string you sent with the mutation params, for matching mutation calls with their responses"
  clientMutationId: String

  "Updated variant"
  variant: ProductVariant!
}
