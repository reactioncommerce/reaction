type Coupon {
  "The coupon ID"
  _id: ID!

  "The shop ID"
  shopId: ID!

  "The promotion ID"
  promotionId: ID!

  "The coupon owner ID"
  userId: ID

  "The coupon code"
  code: String!

  "The promotion can be used in the store"
  canUseInStore: Boolean

  "The number of times this coupon can be used per user"
  maxUsageTimesPerUser: Int

  "The number of times this coupon can be used"
  maxUsageTimes: Int

  "The number of times this coupon has been used"
  usedCount: Int

  "Coupon created time"
  createdAt: Date!

  "Coupon updated time"
  updatedAt: Date!
}

extend type Promotion {
  "The coupon code"
  coupon: Coupon
}

"Input for the applyCouponToCart mutation"
input ApplyCouponToCartInput {

  shopId: ID!

  "The ID of the Cart"
  cartId: ID!

  "The coupon code to apply"
  couponCode: String!

  "The account ID of the user who is applying the coupon"
  accountId: ID

  "Cart token, if anonymous"
  token: String
}

"The input for the createStandardCoupon mutation"
input CreateStandardCouponInput {
  "The shop ID"
  shopId: ID!
  
  "The promotion ID"
  promotionId: ID!

  "The coupon code"
  code: String!

  "Can use this coupon in the store"
  canUseInStore: Boolean!
  
  "The number of times this coupon can be used per user"
  maxUsageTimesPerUser: Int

  "The number of times this coupon can be used"
  maxUsageTimes: Int
}

input CouponQueryInput {
  "The unique ID of the coupon"
  _id: String!

  "The unique ID of the shop"
  shopId: String!
}

input CouponFilter {
  "The expiration date of the coupon"
  expirationDate: Date

  "The related promotion ID"
  promotionId: ID

  "The coupon code"
  code: String

  "The coupon name"
  userId: ID
}

"The response for the applyCouponToCart mutation"
type ApplyCouponToCartPayload {
  cart: Cart
}

type StandardCouponPayload {
  success: Boolean!
  coupon: Coupon!
}

"A connection edge in which each node is a `Coupon` object"
type CouponEdge {
  "The cursor that represents this node in the paginated results"
  cursor: ConnectionCursor!

  "The coupon node"
  node: Coupon
}

type CouponConnection {
  "The list of nodes that match the query, wrapped in an edge to provide a cursor string for each"
  edges: [CouponEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [Coupon]

  "Information to help a client request the next or previous page"
  pageInfo: PageInfo!

  "The total number of nodes that match your query"
  totalCount: Int!
}

extend type Query {
  "Get a coupon"
  coupon(
    input: CouponQueryInput
  ): Coupon

  "Get list of coupons"
  coupons(
    "The coupon ID"
    shopId: ID!

    "Return only results that come after this cursor. Use this with `first` to specify the number of results to return."
    after: ConnectionCursor

    "Return only results that come before this cursor. Use this with `last` to specify the number of results to return."
    before: ConnectionCursor

    "Return at most this many results. This parameter may be used with either `after` or `offset` parameters."
    first: ConnectionLimitInt

    "Return at most this many results. This parameter may be used with the `before` parameter."
    last: ConnectionLimitInt

    "Return only results that come after the Nth result. This parameter may be used with the `first` parameter."
    offset: Int

    filter: CouponFilter

    sortBy: String

    sortOrder: String
  ): CouponConnection
}

extend type Mutation {
  "Apply a coupon to a cart"
  applyCouponToCart(
    "The applyCouponToCart mutation input"
    input: ApplyCouponToCartInput
  ): ApplyCouponToCartPayload

"Create a standard coupon mutation"
  createStandardCoupon(
    "The createStandardCoupon mutation input"
    input: CreateStandardCouponInput
  ): StandardCouponPayload
}
