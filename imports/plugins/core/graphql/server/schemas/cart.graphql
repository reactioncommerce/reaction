"The cart holds selected items until order is placed."
type Cart implements Node {
  "The Cart ID"
  _id: ID!

  # Enforce database uniqueness such that an account only has one cart.
  "The account that owns the cart. Some carts are created for anonymus users. Anonymous carts have a null account."
  account: Account

  "The date and time at which the cart was created, which is when the first item was added to it."
  createdAt: DateTime!

  "The items that have been added to the cart. A cart is not created until the first item is added. Items can be removed from a cart, and a cart is not deleted if all items are removed from it. Because all items may have been removed, this may be an empty array."
  items(after: ConnectionCursor, before: ConnectionCursor, first: ConnectionLimitInt, last: ConnectionLimitInt, sortOrder: SortOrder = desc, sortBy: CartItemsSortByField = addedAt): CartItemConnection

  "The shop that owns the cart."
  shop: Shop!

  "The date and time at which this cart was last updated."
  updatedAt: DateTime!

  # Read-only: Carts that don't have an account should be considered anonymous
  # and should be cleaned up after some time. This should not be set explicitly
  # on the cart but can be derived and add to the Cart as a read-only
  # attribute (read, value from a function.) The cart expiration ttl can then be
  # modified without having to modify cart records.
  # This value should not be stored in the database.
  # Cart expiry is: updated_at + cart_expiry_threshold < now
  "The date and time at which the cart will expire. Account carts usually do not expire, so they will have a null value here."
  expiresAt: DateTime
}

enum CartItemsSortByField {
  _id
  addedAt
}

"Wraps a list of `CartItem`s, providing pagination cursors and information."
type CartItemConnection implements NodeConnection {
  edges: [CartItemEdge]
  nodes: [CartItem]
  pageInfo: PageInfo!
  totalCount: Int!
}

"A connection edge in which each node is a `CartItem` object"
type CartItemEdge implements NodeEdge {
  cursor: ConnectionCursor!
  node: CartItem
}

type CartItemAttribute {
  "The attribute label, e.g., Color"
  label: String!

  "The attribute value, e.g., Blue"
  value: String!
}

"""
A single item in a cart. The item contains information about an intended purchase.
"""
type CartItem implements Node {
  "The cart item ID"
  _id: ID!

  "The date and time at which this item was added to the associated cart. If an item is added, removed, and then added again, this will reflect the most recent addition."
  addedAt: DateTime!

  """
  Additional attributes of the chosen item. For example, if this item is for a product, socks, where "blue" and "small"
  options were chosen for some configurable attributes, then "color:blue" and "size:small" will be indicated here.
  """
  attributes: [CartItemAttribute]

  "The date and time at which the cart item was created. If an item is added, removed, and then added again, the original item is destroyed and this field will reflect the time it was created for the most recent addition."
  createdAt: DateTime!

  """
  The current quantity at the time of fetching this cart item. Use for displaying stock messages like "only 3 left!"
  """
  currentQuantity: Int

  "The URL for a picture of the item"
  imageUrl: String

  "Arbitrary additional metadata about this cart item."
  metafields: [Metafield]

  "Packing information such as item weight, height, length, and depth. Used for calculating shipping rates."
  parcel: ShippingParcel

  "The current price of the item"
  price: ProductPricingInfo!

  # This will permit us to perform calculations based on how the price has changed since
  # the item was added to the cart.
  "The price at which this item was listed when it was added to the cart"
  priceWhenAdded: ProductPricingInfo!

  "The product and chosen options"
  productConfiguration: ProductConfiguration!

  "The product's slug"
  productSlug: String

  "The type of product, used to display cart items differently"
  productType: String

  "The quantity of this item that has been added to the cart. This must be a positive integer. Remove this `CartItem` from it's associated cart if you want `0` of this item."
  quantity: Int!

  # QUESTION: This implies that cart items can be from different shops.
  # Is it possible that certain shops share a cart but other shops are not
  # included in that sharing? How is that defined? Probably not applicable on
  # the cart item but at the cart itself.
  "The shop associated with this cart item."
  shop: Shop!

  "A title for use in cart/orders that conveys the selected product's title + chosen options"
  title: String!

  "The date and time at which this item was last updated"
  updatedAt: DateTime!
}

"Product configuration data"
type ProductConfiguration {
  # This is Product ID, but should not be used to couple the cart item or product configuration to the Product
  # We're adding Product to the cart which is why we're not using the CatalogProductId here
  "The Product ID"
  productId: ID!

  "The ProductVariant ID"
  productVariantId: ID!
}

enum CartReconciliationMode {
  merge
  keepAccountCart
  keepAnonymousCart
}

####################
# Queries
####################

extend type Query {
  "Finds a cart by the cart ID and anonymous cart token."
  anonymousCartByCartId(cartId: ID!, token: String!): Cart

  # Access control should ensure that only authenticated users can find their own
  # cart. Additionally, administrative roles can find carts.
  # Shop ID is necessary if shops have separate carts but share the same account pool
  "Find a cart for a given account ID."
  accountCartByAccountId(accountId: ID!, shopId: ID!): Cart
}

####################
# Inputs
####################

input CreateCartInput {
  "Array of items to add to new cart."
  items: [CartItemInput]!  # NOTE: Don't allow creation of an empty cart

  "ShopId association for the cart."
  shopId: ID! # NOTE: We'll require shopId though it's not in current code.

  "An optional string identifying the mutation call, which will be returned in the response payload"
  clientMutationId: String
}

input CartItemInput {
  "Arbitrary additional metadata about this cart item."
  metafields: [MetafieldInput]

  "The product and chosen options"
  productConfiguration: ProductConfigurationInput!

  "The number of this item to add to the cart"
  quantity: Int!

  "ShopId from which the product is added."
  shopId: ID!

  # Server to ensure that the client price is the same as the server price
  # Inform customer that prices are different and offer to "add anyway" or "cancel" if not.
  "The current price of this item"
  price: Float!

  "The currency for the `price` and `priceWhenAdded` fields"
  priceCurrency: String!
}

input ProductConfigurationInput {
  "The Product ID"
  productId: ID!

  "The ProductVariant ID"
  productVariantId: ID!
}

input AddCartItemsInput {
  "The cart ID"
  cartId: ID!

  "Array of items to be added to the cart"
  items: [CartItemInput]!

  "An optional string identifying the mutation call, which will be returned in the response payload"
  clientMutationId: String
}

input RemoveCartItemsInput {
  "The cart ID"
  cartId: ID!,

  "Array of items to remove from the cart."
  cartItemIds: [ID]!

  "An optional string identifying the mutation call, which will be returned in the response payload"
  clientMutationId: String
}

input UpdateCartItemInput {
  "The cart item ID"
  cartItemId: ID!

  "New absolute value for specified cart item's quantity. Not an incremental value."
  quantity: Int!
}

input UpdateCartItemsQuantityInput {
  "The cart ID"
  cartId: ID!

  "Array of cart item quantities to update."
  items: [UpdateCartItemInput]!

  "An optional string identifying the mutation call, which will be returned in the response payload"
  clientMutationId: String
}

input ReconcileCartInput {
  "An anonymous cart ID"
  anonymousCartId: ID!

  "An anonymous cart token"
  anonymousCartToken: String!

  "If both an anonymous cart and a cart for the authenticated account are found, how do we combine them? Default mode is `merge`, where all anonymous items are moved into the account cart along with existing account cart items, and quantities are combined."
  mode: CartReconciliationMode

  "An optional string identifying the mutation call, which will be returned in the response payload"
  clientMutationId: String
}


####################
# Payloads
# These types are used as return values for mutation calls
####################

"The payload returned from the `createCart` mutation call"
type CreateCartPayload {
  "The modified cart"
  cart: Cart!

  "The same string you sent with the mutation params, for matching mutation calls with their responses"
  clientMutationId: String
}


"The payload returned from the `addCartItems` mutation call"
type AddCartItemsPayload {
  "The modified cart"
  cart: Cart!

  "The same string you sent with the mutation params, for matching mutation calls with their responses"
  clientMutationId: String
}


"The payload returned from the `removeCartItems` mutation call"
type RemoveCartItemsPayload {
  "The modified cart"
  cart: Cart!

  "The same string you sent with the mutation params, for matching mutation calls with their responses"
  clientMutationId: String
}


"The payload returned from the `updateCartItems` mutation call"
type UpdateCartItemsQuantityPayload {
  "The modified cart"
  cart: Cart!

  "The same string you sent with the mutation params, for matching mutation calls with their responses"
  clientMutationId: String
}


"The payload returned from the `reconcileCart` mutation call"
type ReconcileCartPayload {
  "The modified cart"
  cart: Cart!

  "The same string you sent with the mutation params, for matching mutation calls with their responses"
  clientMutationId: String
}

####################
# Mutations
####################

extend type Mutation {
  # Enforce that at least one item is provided so we don't create empty carts.
  #
  # IMPORTANT: CartID must be treated as (or more) securely as a session ID. We
  # need to prevent brute-force cart id collisions.
  #
  #   See: https://www.owasp.org/index.php/Session_Management_Cheat_Sheet
  #
  #   * ID value must provide at least 64 bits of entropy (if a good PRNG is
  #     used, this value is estimated to be half the length of the session ID).
  #   * If a session ID with an entropy of 64 bits is used, it will take an
  #     attacker at least 292 years to successfully guess a valid session ID,
  #     assuming the attacker can try 10,000 guesses per second with 100,000
  #     valid simultaneous sessions available in the web application [2].
  #
  "Create a new cart."
  createCart(input: CreateCartInput!): CreateCartPayload!

  # Add an item to cart.
  # If the item already already exists in the cart, then increment quantity.
  "Add item(s) to a cart."
  addCartItems(input: AddCartItemsInput!): AddCartItemsPayload!

  # Once added to cart, items should be referenced by their cart item ID.
  # Enforce that at least one item is in the list.
  "Remove item(s) from a cart."
  removeCartItems(input: RemoveCartItemsInput!): RemoveCartItemsPayload!

  # If cart item input is set to 0, then remove the item.
  "Update cart item(s) quantity. Use absolute quantity."
  updateCartItemsQuantity(input: UpdateCartItemsQuantityInput!): UpdateCartItemsQuantityPayload!

  # Reconcile Cart
  "Reconcile an anonymous cart with Account cart, if it exists."
  reconcileCart(input: ReconcileCartInput!): ReconcileCartPayload!
}
